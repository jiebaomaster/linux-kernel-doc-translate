# 调度程序基准测试调查
多年来，内核开发人员已使用许多基准测试来测试调度程序的性能。但是最近的内核提交消息显示了正在使用的工具的特定模式（一些相对较新的），所有工具都是专门为开发调度程序补丁而创建的。尽管每个基准测试都有所不同，但都有各自独特的起源故事和预期的测试方案，但有一个统一的属性，它们都是为了抚平开发人员的渴望而写的。

**Hackbench**
[Hackbench](http://manpages.ubuntu.com/manpages/xenial/man8/hackbench.8.html)是一个消息传递调度程序基准测试，允许开发人员配置通信机制（管道或套接字）和任务配置（POSIX线程或进程）。该基准测试是内核调度程序测试的坚强后盾，并且拥有比《蝙蝠侠》系列更多的版本。它最初由Rusty Russell于2001年创建，目的是演示多队列调度程序补丁系列的改进性能。多年来，包括Ingo Molnar，Yanmin Zhang和David Sommerseth在内的许多人都对Russell的版本做出了贡献。 Hitoshi Mitake在2009年将最新的化身作为perf-bench工具的一部分添加到了内核源代码树中。

这是perf-bench的输出示例：
```shell
$ perf bench sched pipe
    # Running 'sched/pipe' benchmark:
    # Executed 1000000 pipe operations between two processes

         Total time: 3.643 [sec]

           3.643867 usecs/op
             274433 ops/sec
```

基准测试的输出是平均调度程序唤醒延迟——任务唤醒以执行工作和该任务在CPU上运行之间的持续时间。在分析延迟时，重要的是要查看尽可能多的延迟样本，因为异常值（高延迟值）可以被汇总统计信息（例如算术平均值）隐藏。如果您仅有的数据是平均延迟，则很容易错过那些高延迟事件，但是调度程序唤醒延迟会很快导致严重的性能问题。

因为hackbench会计算在两个任务之间传递固定数量的数据所需的平均延迟，所以开发人员最常使用它来更改调度程序的负载平衡代码。另一方面，由于缺乏用于分析整个延迟分布的数据，因此如果不使用跟踪工具，则很难深入研究调度程序延迟唤醒问题。

**Schbench**
[schbench](https://git.kernel.org/pub/scm/linux/kernel/git/mason/schbench.git/)是一项可为调度程序唤醒提供详细的延迟分布统计信息的基准测试。 它允许用户配置通常的参数，例如任务数和测试持续时间，还可以配置唤醒之间的时间（--sleeptime），唤醒后的spinning时间（--cputime）； 它还具有自动增加任务数的功能，直到第99个percentile的唤醒延迟变得极端。

Schbench由克里斯·梅森（Chris Mason）在2016年创建，同时向前移植了Facebook为了改善其[工作负载性能](https://marc.info/?l=linux-kernel&m=145987986404475)而携带的一些内核补丁。 梅森在一封私人电子邮件中说：“ Schbench允许我在向前移植旧补丁时快速测试各种理论。” 此后，它变得不仅仅有用，而且Facebook现在将其用于性能回归检测，调查性能问题并在补丁发布到上游之前对其进行基准测试。

这是显示schbench产生的详细统计信息的示例：
```shell
$ ./schbench -t 16 -m 2
    Latency percentiles (usec)
	50.0000th: 15
	75.0000th: 24
	90.0000th: 26
	95.0000th: 30
	*99.0000th: 85
	99.5000th: 1190
	99.9000th: 7272
	min=0, max=7270
```

schbench在基准测试运行结束时打印的调度程序唤醒等待时间分布是它的显着特征之一，并且是创建它的主要原因之一。 梅森继续说：“最重要的部分是关注p99延迟而不是平均延迟。对我们来说，许多问题只有在您开始观察延迟图中的长长的末尾时才会出现。” 这也是一个真正的微基准测试，仅包含模拟Facebook工作负载所需的最少代码，同时确保调度程序是代码路径中最慢的部分。

发布该基准测试提供了一个与上游开发人员讨论Facebook工作负载的通用工具，现在非Facebook工程师正在使用它来测试其调度程序更改，Mason非常满意：“当我看到人们使用schbench时，我非常感激以帮助验证即将推出的新补丁。”

**Adrestia**
[Adrestia](https://github.com/mfleming/adrestia)是一个简单的调度程序唤醒延迟微基准测试，包含的代码比schbench还要少。 我在2016年编写了它，以在不使用schbench的情况下使用futex（）系统调用的情况下测量调度程序延迟，以通过在调度程序唤醒路径中测试其他内核子系统来提供更多覆盖范围。我还需要一些琐碎且配置简单的东西。尽管schbench对Facebook的工作负载进行建模，但Adrestia的设计目的只是提供第95个percentile的唤醒延迟值，该值为以下问题提供了简单的答案：“典型的最大唤醒延迟值是多少？”

我使用adrestia来检测合并的补丁的性能下降，并在将潜在的补丁发布到linux内核邮件列表中时对其进行验证。 它对于触发由cpufreq代码的更改引起的回归特别有用，主要是因为我测试的唤醒时间是32毫秒（Linux调度周期）的倍数。使用调度周期的倍数可以在下一次唤醒之前降低CPU频率，从而可以了解频率选择对调度器唤醒等待时间的影响。 事实证明，这在验证性能时很重要，因为许多企业发行版附带启用了intel_pstate驱动程序并将默认调控器设置为“powersave”。

**Rt-app**
[Rt-app](https://github.com/scheduler-tools/rt-app)是一个高度可配置的实时工作负载模拟器，它接受用于描述任务执行和周期性的JSON语法。它最初是由Giacomo Bagnoli创建的，是其[硕士论文](https://retis.sssup.it/?q=node/77)的一部分，因此他可以创建后台任务来引发调度程序延迟，并测试Linux内核更改以获取低延迟音频。Juri Lelli于2010年左右开始从事deadline调度程序项目的工作，并再次开始其[硕士论文](https://core.ac.uk/download/pdf/14699805.pdf)[PDF]。 Lelli说（在一封私人电子邮件中），他在撰写论文时使用了rt-app，因为这是当时RetisLab（Scuola Superiore Sant'Anna大学）的内部测试解决方案，“我还不知道任何其他能够基于JSON描述创建综合集的工具”。

今天，ARM和Linaro正在使用rt-app来触发特定的调度程序代码路径。它是一种灵活的工具，可用于测试小的调度和负载平衡更改； 这对于生成端到端的工作负载性能和功率指标也很有用。 由于其灵活性（以及表现力的JSON语法），当无法直接运行工作负载（例如主干Linux上的Android基准测试）时，它被广泛用于建模工作负载。Lelli说：“您想使用它来抽象复杂性并测试跨不同平台/操作系统堆栈/后向/前进端口的回归。”

Lelli本人主要将其用于处理错误报告，因为他可以对有问题的工作负载进行建模，而不必运行实际的应用程序堆栈。 他还将它用于回归测试。 rt-app源存储库已经为过去导致回归的工作负载积累了大量配置。 许多开发人员通过[ARM的LISA框架](https://github.com/ARM-software/lisa)间接运行rt-app，因为LISA进一步抽象了rt-app配置文件的创建，并且还包括用于对rt-app跟踪数据进行后置处理的库。

如果在测试调度程序更改时需要对复杂的工作量建模，则rt-app似乎是显而易见的选择。 “对（几乎）任何类型的现实应用程序建模都非常有用，而无需从头开始进行编码-您只需要精通其自己的JSON语法即可。实际上，我相当有信心，例如，这应该不会太难，使用rt-app创建类似{hackbench，cyclictest等}类型的工作负载”。

**最后**
基准提供了其他工具无法提供的好处。它们可以帮助开发人员将工作负载的重要部分还原到其核心，从而使其易于重现所报告的性能问题，并确保性能不会降低，从而传达这些信息。但是，许多性能改善的内核补丁根本没有基准数字。在上述基准测试的帮助下，调度程序子系统的这种情况正在慢慢开始改变。 但是，如果找不到适合您工作量的基准，也许是时候编写自己的基准，并最终解决这一难题了。