# File holes, races, and mmap()
> [原文链接](https://lwn.net/Articles/357767/)

使用`truncate()`的文件操作一直都有竞争条件，开发人员一直关注文件写入与文件大小的竞争。存在各种极端情况，当错误发生时数据可能会丢失或被忽略，或者文件空洞预计为0时可能会出现意外数据。Jan Kara的[patch](http://lwn.net/Articles/353240/)尝试修复此类问题，它依赖于新的[truncate sequence](http://lwn.net/Articles/341352/)，该序列纠正了设置文件的inode大小的方式。

## 空洞

文件空洞是用零表示的区域。当数据以超出当前文件大小的偏移量写入，或者文件被“截断”到大于当前文件的大小时创建。原文件的结尾和新写入数据之间的这段空间被零填充。大多数的文件系统都足够智能，可以在inode上标记文件空洞而不是将其存储在物理磁盘上(这些也称之为稀疏文件)。文件系统在inode中标记blocks以表示它们是空洞的一部分，当用户从空洞的偏移量请求数据时，文件系统将创建一个零填充页面并将其传递到用户空间。

当空洞未与文件系统块边界对齐时，空洞的处理将变得有些棘手，在这种情况下，文件快的一部分必须清零以表示文件空洞。例如，在一个文件块大小为4KB的文件系统中有一个12KB的文件，该文件有一个8192字节的空洞，空洞的起始偏移量为2500。则需要将第一块最后的1596(4096-2500)字节设置为零，第三块的前2500字节也要设置为零。第二块在索引节点的数据块列表被绕过，并且不占用磁盘上的任何空间。

![picture](https://static.lwn.net/images/file-hole.png)

## mmap
`mmap()`是一个系统调用，用于将文件的内容映射到内存中。该系统调用需要映射文件的地址、文件描述符、要映射文件内的偏移量以及要映射的偏移量中的数据长度。通常传递的地址是NULL，以便内核可以选择一个地址并将其传递给进程，mmap可以通过两种方式执行：

* 私有映射：由MAP_PRIVATE定义，此映射对于进程来说是私有的。任何对数据的修改都不会映射到文件中。如果进程要修改数据，则会复制页面并在新的页面中执行修改，这通常称为写时复制(COW)
* 共享映射：由MAP_SHARED定义，该映射可以在进程间共享，并可以作为进程间通信的有效工具(IPC)。在文件中执行的所有修改操作都会回写到磁盘，并且可以供其他进程读取。但是数据写到磁盘并不保证实时性，并且通常在进程调用`msync()`或`munmap()`的时候执行。

当一个进程调用`mmap()`，内核会设置虚拟内存区域(VMA)以将文件映射到内存。它将文件的`struct vm_operations`分配给`vma-> vm_ops`，`vm_operations`包含一组函数指针，这些函数有助于将页面按需存储到内存中。当用户访问主存中不存在的vma时会调用[vm_operations.fault()](http://lwn.net/Articles/242625/)，他负责从磁盘获取页面并将其放入内存。如果vma是共享的，`vm_operations.page_mkwrite()`使页面可写，否则使用COW复制该页面。`page_mkwrite()`负责跟踪文件系统所需的所有信息，例如buffer_heads，以将数据放回磁盘。通常，这意味着准备要写入的块，检查是否由足够的磁盘空间(如果没有返回`ENOSPC`)并提交写入。

`page_mkwrite()`中的当前顺序会与`truncate()`执行的文件大小更改竞争。从共享的`mmap()`写回数据时发生文件截断可能会导致意外的结果，例如数据丢失或数据丢失在需要零填充的地方。

## 数据丢失

在程序中将文件映射到大于当前文件大小的内存的情况下，程序中的数据可能会发生丢失。要说明如何发生数据丢失现象，考虑以下代码片段，在一个块大小为1024字节，页面大小为4096字节的系统上写入文件：
```C
ftruncate(fd, 0);
pwrite(fd, buf, 1024, 0);

map = mmap(NULL, 4096, PROT_WRITE, MAP_SHARED, fd, 0);
map[0] = 'a';  /* page_mkwrite() for index 0 is called */
```

请注意即使文件大小为1024字节，映射也会映射到4096字节，这超出了文件大小。这是可行的，因为文件中的页面按页面大小块进行映射。由于共享内存发生更改，因此这会使页表中的条目变为可写状态。

```C
pwrite(fd, buf, 1, 10000);
map[3000] = 'b';
fsync(fd); /* writepage() for index 0 is called */
```

当调用第一个`page_mkwrite()`时只有block0会分配，因为文件大小可以容纳1024字节。但是，当程序稍后增加文件大小并调用`fsync()`时，`writepage()`需要再分配三个块来完成由`map[3000]`造成的文件写入。在那种情况下如果用户配额用尽或者文件系统没有足够的空间，`map[3000]`修改的数据将被忽略。

## 空洞中意外的非零

如果进程在扩展文件之后，在页面清零和写入之前死亡，则非零字符可能会陷入一个空洞。为了理解这个问题，考虑以下代码片段：

```C
ftruncate(fd, 1000);
map = mmap(NULL, 4096, PROT_WRITE, MAP_SHARED, fd, 0);
while (1)
    map[1020] = 'a';
```

程序在偏移量1020处连续的写。在将页面写入磁盘前，内核将页面从1000到4096置零，但是可以在内核将页面清零后设置`map[1020]`，该页面已解锁并设置为可回写。在这种情况下非零字符会被写入磁盘，这不是问题，因为它超出了文件大小的范围。但是如果另一个进程增加了文件的大小(从而增加了空洞的大小)，并且在重新归零和写入之前被杀死，则下一次读取文件时“脏字符”会被读取。无论文件块大小如何都会存在此问题，用于演示此问题的完整程序[在此](http://news.gmane.org/find-root.php?message_id=%3C20090616144217.GA18063%40duck.suse.cz%3E)发布

## 解决方式

Jan的补丁程序引入了辅助功能，这些功能有助于创建空洞：`block_prepare_hole()`，`block_finish_hole()`。如果监测到当前文件位置超出当前文件大小(即用于创建空洞)，则分别在地址空间操作的`write_begin()`和`write_end()`调用这些函数。`write_begin()`和`write_end()`通常在`page_mkwrite()`中被调用。空洞中的页面部分在`block_prepare_hole()`中清零而不是`block_write_full_page()`。该页面在整个`page_mkwrite()`保持锁定状态，因此可以防止其他进程进行写操作。仅在释放页面锁定并序列化序列后，才可以执行截断操作。这解决了杂散数据可能落在空洞中的问题。

另一方面，block_finish_hole()负责将空洞中页面的一部分标记为只读，如果进程尝试在属于该页面的空洞的一部分中写入任何内容，则将调用page_mkwrite()。如果需要的话，内核有机会分配buffer_heads进行额外的写操作，或者在ENOSPC或EDQUOT的情况下返回错误。如果有错误，write_begin()将返回它，因此，修改映射的内存区域将返回错误（SIGSEGV）。将数据写回到磁盘的功能block_write_full_page（）会检查页面中所有页面的缓冲区，而不只是检查文件大小内已延迟或映射的缓冲区。 新的截断序列确保执行此操作时文件不会被截断。这样解决了数据丢失的问题。

该修补程序在结构体address_space_operations中引入了一个新字段new_writepage，以存储用于执行writepage的新方法。像新的截断序列一样，该字段是一个临时hack，一旦所有文件系统都遵循将页面写入磁盘的新标准，该字段就会消失。实现新的writepage方法的文件系统必须设置new_writepage并通过在write_page中准备的创建空洞的方法处理带有空洞的块，并在write_end中终止它。在noalloc_page_mkwrite()中恢复了处理page_mkwrite()的旧行为。它不会在页面错误时分配任何块，并将页面中所有未映射的缓冲区标记为已延迟，以便block_write_full_page()写入它们。

simple_create_hole()是一个类似于其余simple_ *函数的新函数，这是在文件中创建孔的简单方法。该功能将页面的一部分归为孔的一部分。每当文件大小被截断超过当前文件大小时，就会调用此函数。

此发布是补丁程序的第三次修订，大多数异议已在前两版中得到解决。由于此补丁程序涉及关闭竞争条件，因此很可能最终将其包含在内。 但是，该系列依赖于新的截断系列，因此它必须等待将这些修补程序合并到主线内核中。而且，必须去除区分新写页的骇人听闻的方法。 这要求所有文件系统过渡到使用新的写页面序列。