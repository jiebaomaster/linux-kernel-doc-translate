# 开发更加节能的调度器

> 原文链接 [Toward a more power-efficient scheduler](https://lwn.net/Articles/546664/)，by Jonathan Corbet，2013-4-10

当系统负载非常轻时，Linux 通过合理地让处理器进入并保持睡眠状态，使系统更省电；当系统负载很重时，Linux 通过快速地完成所有工作，得到很好的省电效果。但是，在轻量级的负载下，调度程序并不总是能够做出正确的决策；而且随着硬件变得越来越复杂，这种情况会变得更糟。有一些内核开发人员正在努力提高调度程序的电源效率，但是要使这些工作进入主线可能还需要一段时间。

## 小任务打包（Small-task packing）

Vincent Guittot 的“小任务打包”补丁集已在 2012 年 10 月进行了[检查](https://lwn.net/Articles/520857/)。随后的[第3个版本](https://lwn.net/Articles/543922/)已于次年 3 月下旬发布。该补丁的想法是：

1. 找出那些偶尔在每个调度域“左侧”运行并最终将会在 CPU0 上运行的进程。
2. 将这些任务收集起来，安排到相对较少的处理器上运行，可使运行效率更高，并且其他空闲的 CPU 不会被这些任务唤醒，使整体上更节能。

只要目标 CPU 不会因运行小任务达到过载状态，系统整体的电源利用率将更好，并且不会影响到吞吐量。

该补丁集使用了 3.8 内核合并的[调度实体级别的负载跟踪](https://lwn.net/Articles/531853/)功能。更好的负载跟踪可以轻松识别系统中的小任务，并能更精确地表征任务的大小。因此，该补丁能够只选择那些 CPU 使用率不超过 20％ 的任务。而且，补丁集中新增了进程运行统计信息，使其能够只选择那些每次最多运行 10ms 的任务。所以小任务指的是 CPU 使用率小于 20% 且每次最多运行 10ms 的任务。这些启发式的算法保证调度程序不会选择打包导致目标 CPU 过载的任务。

实际打包行为发生在唤醒小任务时，因为当调度程序的定期负载均衡触发时，此类任务可能正在休眠。在系统初始化时会给每个 CPU 分配一个“伙伴（buddy）CPU”，当小任务被唤醒时，检查其上一次运行 CPU 的伙伴 CPU，如果该伙伴 CPU 具有轻度负载，则将小任务运行在伙伴 CPU 上。伙伴关系是单向的，小任务将倾向于向数量较少的 CPU 迁移。可以看到，整个打包过程的实际决策开销非常小，只需要在进程唤醒时对一个 CPU 进行负载判断，但这也导致了整个打包过程进行得非常缓慢。

## 功率感知调度（Power-aware scheduling）

Alex Shi 的[功耗感知调度补丁集](https://lwn.net/Articles/545910/)（最近一次[查看](https://lwn.net/Articles/512487/)是在 2012 年 8 月）针对功耗问题采用了更全面的方法。 与 Vincent 的补丁集一样，Alex 的补丁同样有个目标是将小任务收集到相对较少的 CPU 上运行。而且，小任务也只在唤醒（或 fork）时被迁移到通用 CPU。但是，Alex 并没有设置 CPU 的伙伴关系，所以小任务需要检查系统上的所有 CPU，寻找仍然有空闲时间的 CPU 中最繁忙的那一个。

该补丁集对定时负载均衡也有改动。当定时负载平衡触发时，新的逻辑将寻找负载最低的非空闲 CPU，因为如果将他的负载迁移到其他 CPU，这个 CPU 就可能会变得空闲。如果可以找到这种足够低负载的 CPU，其上的所有进程将被迁移到一个负载更高的 CPU 上，这个目标 CPU 必须任具有空闲时间。与 Vincent 的补丁集一样，Alex 的补丁也保存了新的进程运行统计信息，用来帮助进程迁移目标的决策。两个补丁集有一个重要的区别：Vincent 的伙伴 CPU 方案记录了 CPU 的电源拓扑结构，所以能够将进程迁移至由不同电源线供电的 CPU 上，这样一来腾出的 CPU 就可以断电；然而，Alex 的补丁集并不考虑 CPU 电源拓扑结构，只是单纯得将进程迁移到较少数量的 CPU 上。

另一个重要的区别是，当系统有足够多负载时，Alex 的补丁集将放弃聚集小任务，并进入到一种“性能”模式。在性能模式下，主动启发式算法将尝试把任务分散到各个 CPU 运行，以尽快完成工作。从某种意义上讲，性能模式实现了老的“race to idle”思想：当有一定数量的工作要做时，最好是简单地投入所有可用资源以快速完成工作，以使系统重新进入睡眠状态。可以想到，在聚集任务和分散任务的两种模式之间进行切换必定对系统其它部分造成影响。为避免过度的系统抖动，算法用滞后策略防止模式切换和进程迁移过于频繁。

## 异构系统

上述讨论有个基本假设：系统中的所有 CPU 仅在电源连接上有差异，其他各个方面都相同。但是，ARM 推出了“big.LITTLE”架构，将快速且耗电的 Cortex A15 处理器与慢速且高能效的 Cortex A7 处理器封装在同一芯片上，这个架构违反了上面的假设。遗憾的是，Linux CPU 调度程序并未考虑到异构系统，因此在该环境中运行时，并不能做出最佳决策。异构系统的[完整解决方案](https://lwn.net/Articles/541005/)目前尚未出现。但是，人们正在尝试朝正确的方向做出努力，慢慢地一步步接近异构系统上的最佳运行方式。

Morten Rasmussen 的[不均衡 CPU 供电系统上的任务分配补丁](https://lwn.net/Articles/544358/)代表了其中一些努力。与上面介绍的特别关注小任务的补丁不同的是，该补丁关注系统中的所有进程。特别是，如果系统中有一个低功率 CPU 满载，而且存在另一个可用的高功率 CPU，则将尝试迁移那些最耗 CPU 的进程到高功率 CPU 上。这样，计算量更大的作业将运行得更快，性能表现将更好；通过合理使系统进入空闲状态，电源利用率将更高。

该补丁集提供的基准表明，将更多 CPU 密集型任务转向能力更强大的 CPU 时，吞吐量会大大提高。当前内核调度程序有一个相当不正常的行为：当前调度程序跟踪了每个 CPU 的“功率”，用于迁移任务时寻找具有最大可用功率的 CPU 和调度域；但是，在 CPU 功率差异很大的异构环境下，即使大核心 CPU 已有负载且小核心 CPU 处于空闲状态，调度程序也可能认为大核心 CPU 比小核心 CPU 多有更多的可用功率。因此，调度器将更多任务迁移到已有负载的 CPU 中，而使空闲的 CPU 无需做任何工作，这减小了整体吞吐量。Morten 的补丁集解决了这个问题，其补丁集先将任务分散到可用的 CPU 上，再逐渐把更多的工作放在更大的 CPU 上，理论上这种方式将使吞吐量达到最大。

## 总结

上述的所有补丁集已经发布了一段时间了，但是没有一个被合并到 3.10 版本。一部分问题是，更改重度启发式的核心代码总是非常困难的，维护人员需要有非常大的把握：更改不会导致其他工作负载的倒退。另一些麻烦是政治上的，目前有一些支持 big.LITTLE 架构的前驱补丁由于[非技术原因](https://lwn.net/Articles/546688/)被阻塞。长期以来，Linux 是由主要关注企业计算的开发者维护的，当来自不同行业的新一批开发人员开始对它进行改进时，肯定会出现一些问题的。

从某种意义上说，调度的挑战已经以微妙但重要的方式发生了变化。几年前，待解决的问题是决定下一步执行哪些任务以及执行多长时间。CFS 已经非常好地解决了这个问题。现在，调度程序开发人员需要考虑的是在大型复杂系统中，任务该在哪个 CPU 上运行。在此过程中，他们必须尝试最大化吞吐量和功率效率。通常，这两个目标是相辅相成的：最快的工作方式往往是最有效的；有时，这两个目标也存在冲突。观察开发者们如何以适合各种工作负载的方式解决这些问题是非常有趣的。
