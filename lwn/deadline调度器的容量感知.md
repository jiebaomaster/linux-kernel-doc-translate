# deadline调度器的容量感知

> 原文链接https://lwn.net/Articles/821578/; 
> 文章1、文章2对应的中文译文: http://www.wowotech.net/process_management/deadline-scheduler-1.html;  http://www.wowotech.net/process_management/dl-scheduler-2.html

deadline调度器([注]后面简称DL调度器)支持实时系统，在实时系统中应用程序需要确保在特定的时间周期内完成任务。DL调度器在分配cpu时间的时候要满足每个任务的截止时间限制，但是目前的DL调度器不能很好的支持非对称的cpu(比如说arm的[big.LITTLE](https://en.wikipedia.org/wiki/ARM_big.LITTLE))。针对这个问题Dietmar Eggemann最近提交了一个[补丁集](https://lwn.net/ml/linux-kernel/20200520134243.19352-1-dietmar.eggemann@arm.com/)，他把cpu容量(capacity)的概念添加到调度器中。

在实时系统中，任务之间会有一个时序关系(前一个动作完成，执行下一个)，当前Linux中有两个支持实时系统的调度器，分别是RT调度器和DL调度器

RT调度器将进程优先级作为它的调度基础，高优先级的任务先被调度。与RT不同的是DL放弃了优先级的概念，它使用运行时间(runtime)、周期(period)和截止时间(deadline)来描述任务。runtime是进程完成一个周期内的任务需要的时间，period是进程两次唤醒的时间间隔，deadline是指在一个period的deadline时间之前确保可以分配runtime的cpu资源(简单说就是在deadline之前该周期内的任务要执行完毕)。感兴趣的读者可以在[文章1](https://lwn.net/Articles/743740/)找到更多关于这两个实时调度器的理论知识以及他们之间的不同。

## deadline调度器和非对称cpu

DL调度器包含一个接纳(admission)算法，该算法会在任务请求DL调度器的时候执行，并确保系统可以满足任务的需求。如果一个任务的实时性不能得到保证，那么系统中的其他任务都将错过截止时间，因此会拒绝该任务使用DL调度类。然而该算法并不能总是保证截止时间得到满足，它只保证DL任务占有时间的限制并且非DL任务不会被饿死。这是因为在一般情况下能否在截止时间内完成任务取决于系统中已有的任务，在[文章2](https://lwn.net/Articles/743946/)中对此作出解释。

在非对称处理器中DL调度器的工作变得更加复杂，例如big.LITTLE或者DynamIQ。在这种处理器配置中包含不同种类的核心，它们有些性能有高有低，同一个任务在高性能的cpu(大核)上执行时间要低于在低性能cpu(小核)上的执行时间。当前内核的DL调度器并没有考虑这个问题，其结果就是DL调度器会在小核上过度分配时间。DL任务可能会在一个小核上结束，在这种调度方式下它们无法在截止时间前完成，但是放在大核上它们就可以完成。在这种系统中接纳控制算法假设所有的cpu性能都是高性能，这样会使系统接纳过多的deadline任务，从而使系统无法使用。

DL调度器中缺少的信息是对于cpu容量的理解 —— 给定时间内执行的指令数，更多关于这个的计算细节可以在[文章3](https://lwn.net/Articles/639543/)中了解。cpu容量的概念最近被添加到RT调度器中并早已用于负载均衡和其他情况下，例如在cpu过热的时候降低它的频率。Eggemann的工作就是在DL调度器的接纳控制算法和任务分配算法中考虑了cpu 容量。更改之后，DL调度器会在对称和非对称处理器系统上考虑可用容量是否可以满足任务的截止时间，并以此来决定任务的执行cpu。

## The Changes

接纳控制算法根据系统提供的cpu总容量作出决策。在对称系统中所有的cpu容量都相同，总和就是cpu的数量乘以一个常数。即使在非对称系统上当前的内核也是这么计算的，它假设所有cpu的容量是最大的。新的代码在非对称的情况下改变了计算方式，它计算了所有活跃cpu的实际容量。

DL调度器的任务放置也必须更好的理解cpu拓扑结构。在将任务移动到新的cpu之前，调度器需要确保新的cpu可以处理该任务。在非对称系统中需要新型的检查来确定cpu的容量是否可以在截止日期之前完成给定的任务，使用以下公示进行检查：

> (CPU capacity) / 1024 >= (task runtime) / (task deadline)

默认的cpu容量是1024，性能较低的cpu容量会低于这个。公式的左侧计算结果表示一个cpu的相对容量，例如假设一个小核的容量是462，那么它的相对容量就是0.45。根据这个公式，只会允许运行时间和截止时间之比小于等于0.45的任务。一个运行13000us并且截止时间是16000us的任务将不被允许，因为13000 / 16000 = 0.81，大于0.45。

当唤醒一个DL任务，将一个DL任务迁移到另一个cpu，以及将任务从正在脱机的cpu中迁移出来时，都将会使用这个公式检查。在讨论补丁集的较早版本的时候Eggemann展示了一些[容量计算的实例](https://lwn.net/ml/linux-kernel/b72f72c1-6043-c44f-31f5-fb4137bd5d52@arm.com/)。

如果一项任务不能在截止日期前完成，它就会错过最后期限。在DL调度器中这总是会发生的，例如当一个任务被成功接受但是其中一个cpu离线了，系统的总容量就会降低(注: DL并不是严格保证deadline时间的，只保证有限的延迟，容量低会导致延迟增加)。在补丁集中引入了相应的[改动](https://lwn.net/ml/linux-kernel/20200427083709.30262-7-dietmar.eggemann@arm.com/)，在非对称处理器中处理这个情况时调度器会选择可用容量最大的cpu，如果有多个cpu可选会尽可能选择当前cpu，以便更好的利用cache的内容。

## 局限性和未来的工作

DL调度器对非对称系统的支持的工作并非到此为止。目前的补丁集要求至少有一个cpu没有DL任务，否则任务放置仍然可能不正确。对于负载更重的系统的，需要之后解决。

在讨论中，Juri Lelli指出了一个可能的问题：如果一组小的DL任务首先开始，它们将被放置在大型cpu上。此时如果一个更大的任务被接受，它可能找不到足够大的CPU来运行。Luca Abeni（这组补丁的共同作者）回应说，他们有一个新patch，其中调度器会将任务放在能完成工作的最小CPU上。这个patch将在稍后提交。

补丁集已经收到了积极的评价，我们应该期待这个修复将很快成为主线内核的一部分。我们还可以期待在这个领域看到更多的补丁，因为还有更多的工作要做；随着更多非对称CPU架构的出现，用户可能需要在其工作负载中更好地支持此类配置。